Linuxのしくみ
===

# コンピュータシステムの概要

OSとハードウェアの関係、およびOSとはなにか

* Linuxとハードウェアの関係
    * 外部デバイスを操作する処理はデバイスドライバのプログラムにまとめられている
    * プロセスはデバイスドライバを介してデバイスにアクセスする。ユーザモードで直接アクセスすることはできない
* プロセスはユーザモードで、OSの処理をまとめた機能はカーネルモードで動作する。プロセスがカーネルの機能を使いたければシステムコールを使って依頼する

# ユーザモードで実現する機能

ユーザモードで動作するOS機能、システムコールについて

システムコール

* システムコールを発行すると、その間CPUはカーネルモードに切り替わり、終了すればユーザモードに戻る
* `strace`コマンドでシステムコールの発行を確認できる
* CでHello Worldをプリントする単純なプログラムでも、システムコールが30回くらい発行されるらしい。ほとんどがmain関数の前後の初期化終了処理で、プリントの部分は`write()`システムコールだけ

OSが提供するライブラリ

* 標準Cライブラリであるglibc。システムコールのラッパー関数が入っている
* lddコマンドでリンクを確かめることができる

OSが提供するプログラム

* `init`, `sysctl`, `grep`, `sar`, コンパイラ `gcc`, シェル `bash`など馴染みのあるコマンド

# プロセス管理

カーネル内のプロセス生成、廃棄を担当するプロセス管理について

プロセス生成の目的
* 同じプログラムの処理を複数のプロセスに分けて処理する → fork()
* まったく別のプログラムを生成する → execve()

fork()関数

* プロセス生成の流れ
    * 子プロセス用メモリ領域を作成して、親プロセスのメモリをコピーする
    * 親プロセスと子プロセスは違うコードを実行するように分岐する。プロセスIDが異なる

execve()関数

* プロセス生成の流れ
    * 実行ファイルを読み出して、プロセスのメモリマップに必要な情報を読み出す
    * 現在のプロセスのメモリを新しいプロセスのデータで上書きする
    * 新しいプロセスの最初の命令から実行開始する
* 親プロセスからfork()を発行して、復帰後に子プロセスがexec()を呼ぶ、「fork and exec」の流れになることが多い

終了処理

* _exit()関数を使用する
* 通常は標準Cライブラリのexit()関数を呼び出す

# プロセススケジューラ

CPUリソースを管理するプロセススケジューラについて

* コンテキストスイッチ
    * 論理CPU上で動作するプロセスの切り替わり
* プロセスの状態と、ps axコマンドのSTATフィールド
    * 実行状態 R
    * 実行待ち状態 R
    * スリープ状態 S or D
    * ゾンビ状態 Z
* ほとんどのプロセスはスリープ状態になっている
* マルチコアCPU環境では、複数プロセスを同時に動かさないとスループットは上がらない。プロセス数を論理CPU数より多くしてもスループットは上がらない

# メモリ管理

メモリリソースを管理するメモリ管理システムについて

* freeのbuff/cacheフィールドは、バッファキャッシュおよびページキャッシュを利用するメモリ。システムの空きメモリが減少してきたらカーネルによって解放される
* カーネルパラメータ`vm.panic_on_oom` のデフォルト0はOOM発生時にOOM Killer発動、1はOOM発生時にシステムを強制終了させる
* カーネルがプロセスにメモリを割り当てるタイミング
    * プロセス生成時
    * プロセス生成後、追加で動的にメモリを割り当てるとき

仮想記憶

* 仮想記憶は、システムに搭載されているメモリにプロセスから直接アクセスさせるのではなく、仮想アドレスというアドレスを用いて、間接的にアクセスさせる方法
    * 直接アクセスさせると、メモリの断片化や別用途のメモリにアクセスできてしまう
    * プロセスから見えるメモリのアドレスを仮想アドレス、実際のアドレスを物理アドレスと呼ぶ
* ページテーブル
    * 仮想アドレスと物理アドレスの変換表
* glibcのmalloc()は、mmap()システムコールを呼んでメモリ領域を獲得している

仮想記憶の応用

* ファイルマップ
    * ファイルの領域を仮想アドレス空間上にメモリマップする
* デマンドページング
    * 必要に応じて物理ページを論理メモリに割り当てる方式
    * 実際の物理メモリ割り当てはこの方法で行う
* コピーオンライト
    * 仮想記憶を使った、プロセス生成fork()システムコールの高速化の仕組み
    * CoWとも呼ばれる
    * 物理メモリをfork()システムコール発行時ではなく、遅れて書き込み時にコピーされる
* スワップ
    * ストレージデバイスの一部を一時的にメモリの代わりとして使用するしくみ
    * スワップアウトは物理メモリの一部をスワップ領域に退避、スワップインは物理メモリに戻す、これらをまとめてスワッピング
    * メモリ不足のときに起こる
* 階層型ページテーブル
    * ページテーブルが多段になっているページテーブル。仮想アドレスに対する下位のページテーブル情報が書かれており、そのテーブルの中にページテーブルが書かれている
* ヒュージページ
    * 大きいサイズのページテーブル。ページテーブルに必要なメモリ量を減らすことができる

# 記憶階層

記憶装置を構成する記憶階層について

キャッシュメモリ

* 計算を行うレジスタ(CPU)とメモリの間のアクセスを高速化するためのメモリ
* 通常はCPUに内蔵されているが、CPU外についているキャッシュメモリもある
* CPUからキャッシュメモリに書き込まれてメモリに書き込まれていない場合、ダーティであると呼ぶ
* キャッシュメモリがいっぱい、かつ、すべてダーティである場合、キャッシュライン内のデータが激しく入れ替わるスラッシング発生し、性能が劣化する

ページキャッシュ

* ストレージへのアクセスを高速化するために、ストレージのファイルデータをメモリにキャッシュする

ハイパースレッド

* レジスタのなどの一部の資源を複数用意して、それぞれのシステムから論理CPUとして認識されるように分割する仕組み
* データ転送待ち時間などのCPU資源を有効活用できる

# ファイルシステム

通常のデバイスドライバによるアクセスを簡略化するファイルシステムについて

ファイルシステムとは

* どこにどんなデータがあるか、どこが空き容量かを管理するしくみ
* ファイルシステムがないと、メモリからストレージへの書き込みアドレスやサイズなどを自分で指定しなければならない
* システムコールによってアクセスできる
* データの種類には、データとメタデータがある

クオータ

* 用途ごとに使用できるファイルシステムの容量を制限する機能

ファイルシステムの不整合とそれを防ぐ技術

* ジャーナリング
    * ファイルシステム内にジャーナル領域とメタデータの領域を用意してファイルシステムを更新する
    * ファイルシステム更新手順
        * ジャーナルログ(更新に必要なアトミック処理の一覧)を、ジャーナル領域に書く
        * ジャーナル領域の内容に基づいて、実際にファイルシステムの内容を更新する
    * ext4, XFSのファイルシステムが対象
* コピーオンライト
    * 更新されるデータを別の場所に全て書き込んでからリンクを張り替える
    * Btrfsのファイルシステムが対象
* 定期的にバックアップを取ろう

デバイスファイル

* デバイスにファイルとしてアクセスする。/dev以下に存在
* キャラクタデバイス
    * 読み書きはできるがシークはできない
    * 端末、キーボード、マウスなどの入出力デバイス
* ブロックデバイス
    * 読み書き以外にランダムアクセスができる
    * HDD, SSDなどのストレージデバイス

ファイルシステムの種類

* tmpfs
    * メモリベースのファイルシステム
* ネットワークファイルシステム(nfs)
    * リモートホスト上のファイルにアクセスするファイルシステム
* 仮想ファイルシステム
    * procfs
        * システムに存在するプロセスについての情報を得るためのファイルシステム
    * sysfs
        * カーネル情報にアクセスするためのファイルシステム
    * cgroupfs
        * リソース仕様の制限を書けるcgroupを操作するファイルシステム
* Btrfs
    * 複数のストレージデバイス/パーティションから大きなストレージプールを作り、その上にマウント可能なサブボリューム領域を作成する
    * ファイルシステム+LVMのようなボリュームマネージャ

# ストレージデバイス

ストレージデバイスの性能特性、その性能を引き出すためのカーネルの支援機能について

HDD

* データを磁気情報で表現し絵磁気ディスクに記憶するストレージデバイス
* データはバイト単位ではなくセクタと呼ばれる単位で読み書きする
* 性能を上げるための工夫
    * ファイル内のデータを連続する
    * 連続する領域へのアクセスは1回にまとめる
    * ふぁいるにはなるべく大きなサイズでシーケンシャルアクセスする
* ブロックデバイス層の上に構築されたファイルシステムを介して間接的にHDDにアクセスする
* ブロックデバイス層のIOスケジューラは、ブロックデバイスへのアクセス要求を溜めておいて、マージソートをしてからデバイスドライバにIOリクエストをする

SSD

* データへのアクセスに機会的な動作が一切なく、電気的な動作だけになる
