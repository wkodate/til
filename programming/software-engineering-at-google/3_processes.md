III. Processes
===

# 8章　スタイルガイドとルール

Googleのルールとガイダンスの開発を舵取りする原理とプロセス。

Google Style Guide: https://google.github.io/styleguide/

## 8.1　何故ルールを設けるのか

ルールを設置することのゴールは、「良い」行動を促し、「悪い」行動を思いとどまらせる。

コーディングの共通ルールがあれば、どう書くかより何を書くかに集中できる。

## 8.2　ルールを作る

スタイルガイドを作る上でのルール

- なんでもかんでもスタイルガイドに盛り込まない。goto禁止など自明なものは含めない。
- コードを書く人ではなく読む人に向けて最適化する
- ソースコードの一貫性を保つ。これは組織のスケールに役立つ
- 誤りが起きやすいあまり使われない構文の利用を避ける
- 必要ならスタイルガイドルールの例外を許す。パフォーマンス最適化のために一貫性やリーダビリティを犠牲にするなど

スタイルガイドのカテゴリ

- 危険を避けるためのルール。使ってはならない言語機能、正しく使うのが難しい機能の正しい適用方法など。
- ベストプラクティスを強制するためのルール
- 一貫性を保証するためのルール

## 8.3　ルールを変更する

時間の経過によってスタイルガイドを再評価する必要が出てくる。その際は、pros/consやトレードオフを議論し詳細な根拠を元に最終的に変更を決定する。

最終的な決定と承認は、スタイルガイドのオーナーによって行われる。C++は4人のオーナーがいる。

## 8.4　ガイダンス

推奨するベストプラクティス。

ルールが「絶対やらなければならないこと」であれば、ガイダンスは「やるべきこと」。

## 8.5　ルールを適用する

ルールを遵守しているかどうかの確認はツールによって自動化する。

自動化によって、ルールがどのように解釈され適用されるかのばらつきを最小化できる。

また、自動化はルールの強制をスケーラブルにもする。

# 9章　コードレビュー

Googleでは、すべてのコード変更がコミットされる前にレビューされており、園児唖然員がレビューの開始と変更のレビューを担当している

Googleでは、[Critique](https://abseil.io/resources/swe-book/html/ch19.html)と呼ばれるコードレビューツールを使っている。(詳細は19章)

この章ではツールではなく主にプロセスの話。

## 9.1　コードレビューのフロー

1. authorは自分のワークスペースで行った変更をコードレビューツールにアップロード。ツールでは変更差分が表示される。
2. authorは変更を1人以上のreviewerにメールでレビューを依頼する。
3. reviewerは変更を見て差分上にコメントを残す。
4. フィードバックに基づいてauthorは変更を修正し、reviewerに返信。必要に応じて3,4を繰り返す。
5. reviewerが変更に満足したらaproveし、LGTMをする。デフォルトではLGTMが1つあればいいが、全reviewerにapproveを求めても良い。
6. 全コメントを解決してそれがapproveされていれば、authorは変更をコードベースにコミットできる。

## 9.2　Googleでのコードレビューはどのように機能しているか

Approveの3つのポイント

- コードがauthorの期待通りに動作するか。
- コードベースのある特定のディレクトリにおいて適切な変更か。(Googleのコードベースは、特定の各ディレクトリに階層的なownerがいる木構造)
- コードが期待するフォーマットで書かれているか。

## 9.3　コードレビューの恩恵

コードレビュープロセスは当然コード変更に時間がかかるという問題がある。しかし、Gooogleではどんな小さな変更でもコードレビューを義務としている。

このコードレビュープロセス文化は、以下の恩恵をもたらす。

- コードの正しさをチェックできる
- コードが理解可能なものかを確認できる
- コードベース全体で一貫性を強制できる

## 9.4　コードレビューのベストプラクティス

レビュアーを尊重すべき。不十分な場合にのみ代案の指摘をする。

Googleでは24時間以内にレビューのフィードバックがされることが期待されている。できない場合はその旨を返信する。

レビューは小さい変更に留めるべき。200行程度。Googleのコード変更の約35%がたった一つのファイルの変更

レビュアーは最小限に留めるべき。Googleの大半のコードレビューは1名のレビュアーによってレビューされている。

## 9.5　コードレビューの類型

コードレビューの分類

- グリーンフィールドコードレビュー(完全に新しいコードに対するレビュー)
- 挙動の変更、改善、最適化
- バグ修正とロールバック
- リファクタリングと大規模変更

# 10章　ドキュメンテーション

Googleではドキュメントをコードとして扱うのが最も成功しているやり方。

## 10.1　何がドキュメンテーションとして適格か

独立したドキュメントだけでなく、コードのコメントも含まれる。

## 10.2　何故ドキュメンテーションが必要なのか

ドキュメンテーションは時間とともにスケールするし、組織においてもスケールする。

設計上の決定理由、実装の根拠、数年後自分のコードを見返したとき、などでドキュメンテーションは有用

## 10.3　ドキュメンテーションはコードのようなものである

ドキュメンテーションはコードと密結合していることが多いため、できるだけコードとして扱われるべき

Docs as Codeと呼ばれる: https://www.writethedocs.org/guide/docs-as-code/

## 10.4　対象読者を認識せよ

ドキュメンテーションを書く前に、読む対象の読者をはっきりさせる。その読者に応じたスキルレベルとドメイン知識に応じてドキュメントを書くべき。

デザインドキュメントであれば、意思決定者を説得させる内容を書くようになる。

チュートリアルであれば、コードベースに馴染みのない読者になるので、詳細まではっきりと書かなければならない。

主要な想定読者はSeekers(捜索者)とStumblers(遭遇者)

- Seekersは、自分の知りたいことが明確で、コードが要件を満たすかどうかを知りたい
- Stumblersは、自分が知りたいことがクリアになっておらず、コードの目的を説明する概要が知りたい。多くのGoogleドキュメントでは、冒頭にTL;DRが書かれている。

## 10.5　ドキュメンテーションの類型

ドキュメントのタイプによって書き方が異なる

ドキュメントのタイプ

- コードのコメントを含むリファレンスドキュメンテーション
- 作業着手前に承認をもらうための、提案する設計が書かれたデザインドキュメント
- 新しいチームメンバーが新しく構成を知るためのチュートリアル
    - 実行時の手順に番号を明示的に振るのが重要。
    - 各手順は作業者の具体的な作業を書く。サーバ側の処理は、各手順の副作用として記述する。
- リファレンスドキュメンテーションよりも深い説明や知見を要するコードのための、概念的ドキュメンテーション
- チームポータルページのような、ドキュメントのリンクが整理されたランディングページ

## 10.6　ドキュメンテーションのレビュー

ドキュメントレビューの種類

- 正確性のための技術的レビュー
- 明確性のための対象読者レビュー
- 一貫性のための作文法レビュー

## 10.7　ドキュメンテーション哲学

技術的な文章を書くためのベストプラクティス

Howの他に、Who, What, When Where, Whyを意識する。

完全性、正確性、明確性は、優れたドキュメンテーションの特徴的要素

古くなったドキュメントは、削除するか、古いものとして分類する。Googleではドキュメントのメタ情報としてfreshness dateをつけておく。数ヶ月変更がない場合はメールでリマインドを送る。

## 10.8　テクニカルライターが必要なのはどんなときか

Googleでは、昔は重要なプロジェクトはテクニカルライターにドキュメント作成を任せていた。プロジェクトメンバーのドキュメント作成や保守の負担を軽減するため。

しかし、これは誤りであった。対象読者がエンジニアリングチームならプロジェクトメンバーが書くことができる。対象読者がプロジェクトメンバー以外の人であれば、テクニカルライターにお願いする。

テクニカルライターのリソースは限られているので、そのような場合にのみ依頼したほうがスケールする。

# 11章　テスト概観

自動テストの導入にによって、バグを捕捉できる、変更が容易になり変化に合わせて高速に反復できる。

## 11.1　何故テストを書くのか

テストは後からの付け足しであってはならない。プロダクトの構成要素の一つ。

Googleでは、2005年頃にGoogleWebサーバに自動テストのポリシーを追加したことによって、1年以内にロールバックやバグフィックス等の緊急リリースが半減した。

自動テストによって、プロダクトのバグ発見についてプログラマーの能力だけに頼ることを避けることができる、

自動テストは手動デバッグにかけるコストを減らすことができる。

コードの正しさ、エッジケース、エラー条件のテストがコードレビューに含まれていれば、レビューを単純化できる。

テストがあると自信をもってリリースできる。

テストがスケールするには、自動化しなければならない。

## 11.2　テストスイートを設計する

テストには、規模(Size)と範囲(Scope)の2つの次元がある

- 規模は、テストケースの実行に必要なリソース。メモリ、プロセス、時間など。
- 範囲は、検証している特定のコードパス。

テストカバレッジは、テストされていないコードを知りために役立つが、システムがどれだけ適切にテストされているかまではわからない。

### 規模

小テスト

- 単一のプロセスで実行される。シングルスレッド内で実行されなければならない。
- ネットワーク、ディスクへのアクセスを許可されていない。

中テスト

- 単一のマシン上で実行される。スレッドが使える。
- ネットワーク、ディスクへのアクセスはlocalhostのみ許可。

大テスト

- 任意の好きな場所で実行される。
- ネットワーク、ディスクへのアクセスを許可。リモートのクラスタ内のシステムに対してテストを実行しても良い。

テスト環境の構築から解体までをテストに含むべき。外部環境に対する前提条件を持つべきではない。

テスト内での複雑なロジックは避ける。条件分岐やループはなるべき使わない。

### 範囲

狭い範囲のテスト(ユニットテスト)、中範囲のテスト(インテグレーションテスト)、大範囲のテスト(ファンクショナルテスト、エンドツーエンドテスト、システムテスト等)

Googleのガイドラインとして、これらテストの割合は、小テスト80%、中テスト15%、大テスト5%を目指している。

## 11.3　Google規模でのテスト

Googleのコードの大半がモノレポで管理されている。

テストが遅くなると、生産性が下がる。質の高いテストを保つため、テストを改善したエンジニアに対しても新機能リリースと同等となるようなインセンティブを与えるべき。

## 11.4　Googleでのテストの歴史

テスト文化を構築するためにGoogleが行っている試み

- オリエンテーション講習
- テスト認定プログラム
- トイレでのテスト(Testing on the Toilet/TotT)。社内のトイレの個室にテストに関するTipsを貼って、社員のテストに関する意識を高める。
    - Introducing "Testing on the Toilet”: https://testing.googleblog.com/2007/01/introducing-testing-on-toilet.html

## 11.5　自動テストの限界

自動テストは必ずしもすべてのテストに適しているわけではない。

検索結果の品質チェックなどは、人間によるチェックが必要な場合がある。

# 12章　ユニットテスト

テストのメンテナンス性(Maintainability)とそれを達成するためのテクニックについて

## 12.1　保守性の重要さ

テストの保守性とは、「just work」するものであり、テストが失敗するまではそのテストについて考える必要がなく、テストの失敗時は明確にバグがあることが示される状態。

テスト保守性のために、

- 脆いテストを防ぐ
- 明確なテストを書く

## 12.2　脆いテストを防ぐ

脆いテストとは、コードの変更でバグがないにも関わらず無関係なテストが失敗してしまうこと。

理想のテストは、変化しないテスト。

テストを書いた後、システムをリファクタリングし、バグを修正し、新機能を追加する際に、そのテストに再度触れなければならないというのは何かが間違っているということである。

公開APIに対してテストをすれば、それが失敗した時ユーザのアクティビティもまた失敗することがわかる。

相互作用(インタラクション)ではなく状態(ステート)をテストする。つまり、どのようにその結果になったかの過程をそれぞれテストするのではなく、どういう結果になったかだけをチェックする。例えば、ユーザ追加のテストでHTTP PUTメソッドが呼ばれたことをチェックするのではなく、オブジェクトにユーザが追加されたかどうかをチェックする。

## 12.3　明確なテストを書く

テストが失敗した時、テスト対象に問題があるか、テスト自体に問題があるかを特定し、問題を究明する。

テストは完全かつ簡潔にする。つまり、読み手が必要なすべての情報が含まれていて、他の無関係な紛らわしい情報が含まれていない。

メソッドに対してではなく、各挙動に対してテストを書く。

テストの名称は、テスト対象の挙動を要約する。システムに対して行われる動作と、期待される結果が含まれていると良い。困ったら、shouldで始めるのが良い。

## 12.4　テストとコード共有：DRYではなくDAMP

テストにおいては、DRY(Don’t repeat yourself)ではなくDAMP(Descriptive And Meaningful Phrases)。

「説明的かつ意味がわかりやすい言い回し」。テストを単純かつ明確なものにするのであれば、多少の重複は許容される。
