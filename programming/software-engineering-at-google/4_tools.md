IV. Tools
===

# 16章　バージョンコントロールとブランチ管理

なぜバージョンコントロールの利用がソフトウェアエンジニアリングにおいてスタンダードになったのか。

## 16.1　バージョンコントロールとは何か

```
VCS(ファイル名, 時刻, ブランチ) => ファイルの内容
```

1,2日以上のプロジェクトであれば、開発者が一人でもバージョンコントロールを使うだろう。

中央集権的VCS(Subversionなど)から、分散VSC(Git)へ。これらの違いは、どこにコミットできるか、ファイル群のうちどれをリポジトリとみなすか。

## 16.2　ブランチ管理

トランクベース開発、存続期間の長いdevブランチが存在しない、が優れた技術的結果につながる。

どのバージョンに依存すべきか、の選択の余地があることは組織のスケールを妨げる。

## 16.3　Googleでのバージョンコントロール

単一バージョンルール: 開発者には、「このコンポーネントのどのバージョンに依存すべきか」についての選択の余地があってはならない。

開発ブランチは最小限にしておくか、せいぜい非常に短命であるべき。

## 16.4　モノリポ

単一バージョンルールを守ることができるのなら、MonorepoでもManyrepoでも良い。

Googleのモノレポに関する記事(2015年)。[20億行のコードを保存し、毎日4万5000回のコミットを発行しているGoogleが、単一のリポジトリで全社のソースコードを管理している理由 － Publickey](https://www.publickey1.jp/blog/15/2045000google.html)

## 16.5　バージョンコントロールの未来

大規模なリポジトリでスケーリングが可能になる。

リポジトリ間の依存関係が管理しやすくなり、大規模なリポジトリの必要性がなくなる。

# 17章　Code Search

Googleのコード閲覧と検索のためのツール。UIとバックエンドで構成される。

## 17.1　Code SearchのUI

検索ボックスがUIの中心的な要素。候補、ファイル内検索、ファイルの履歴など。

コマンドラインからも利用できる。

## 17.2　グーグラーはどのようにCode Searchを使うか

このコードはコードベース内のどこに(where)存在するか、このコードは何を(what)行っているか、なぜ(why)やっているか、この処理をどのように(how)行っているか、git blameのように誰が(who)いつ(when)このコードを導入したか

## 17.3　何故独立したウェブツールなのか

Googleのコードベースは非常に大規模であるため、ローカルにコードベース全体が入り切らない。

IDEではないので、コード編集機能はない。これによって、ショートカットやクリックなどの操作を、コードの閲覧と理解に最適化できる。

ログやドキュメントからのリンクが容易になる。

エディタやIDEのためのプラグインが用意されている。

## 17.4　設計上でのスケールの影響

レイテンシの低下は開発者の生産性を低下させる。これを防ぐために、頻繁な操作においては200ms以下のレイテンシを目標にする。

変更したコードが即座にインデックスされる必要がある。

## 17.5　Googleの実装

Code Searchのインデックスは元のtrigramから、カスタムなsuffix array(接尾辞配列)ベースを経て、トーンベースのn-gramへ移行した。インデックスを大きくし、転置インデックスの数とサイズの両方を減らした。

ランキングのシグナル(各ファイルの特徴のセット)は、ドキュメントにのみ依存するクエリ独立シグナルと、クエリがどうドキュメントにマッチするかに依存するクエリ依存シグナルに分けられる。

## 17.6　選択されたトレードオフ

複雑さ vs 機能強化: インデックスからいくつかのファイル(バイナリなどの非テキストファイル、自動生成されたjsファイル)を除外することで、ノイズが減り検索クエリは早くなるが、完全性が犠牲になる。

ヘッド vs ブランチ vs 全履歴 vs ワークスペース: どのバージョンがインデックスされるべきかのトレードオフ。現在のバージョン以外をインデックス化すべきか。

トークン vs 部分文字列 vs 正規表現: トークンベースはよくスケールするが、検索が難しくなる。部分文字列は軽量だがクエリの精度が落ちる。正規表現は強力な検索機能を提供するが、インデックスの作成が困難。
